# Глава 1: Введение

## Введение Майкла Стоунбрейкера

Выбранные чтения:

* Джозеф М. Хеллерстайн и Майкл Стоунбрейкер. "Что было, то и будет". Чтения по системам баз данных, 4-е издание (2005).
* Джозеф М. Хеллерстайн, Майкл Стоунбрейкер, Джеймс Гамильтон. "Архитектура системы баз данных". Основы и тенденции в базах данных, 1, 2 (2007).

Я поражен тем, что эти две статьи были написаны всего десятилетие назад! Мое удивление по поводу статьи об анатомии связано с тем, что детали изменились значительно всего через несколько лет. Мое удивление по поводу статьи о модели данных связано с тем, что никто, кажется, не учится на истории. Давайте сначала поговорим о статье о модели данных.

Десятилетие назад все говорили о XML. Поставщики стремились добавить XML в свои реляционные движки. Аналитики отрасли (и более чем несколько исследователей) провозглашали XML как "следующую большую вещь". Десятилетие спустя это нишевой продукт, и область продвинулась дальше. По моему мнению, (как предсказано в статье) он пал жертвой сочетания:

* чрезмерной сложности (которую никто не мог понять),
* сложных расширений реляционных движков, которые не показали хорошей производительности,
* отсутствия убедительного случая использования, где он был бы повсеместно принят.

Иронично, что в статье было предсказано, что X выиграет премию Тьюринга за успешное упрощение XML. Это предсказание оказалось совершенно неверным! В итоге победили реляционные базы данных, а XML проиграл.

Конечно, это не остановило "новичков" от изобретения колеса заново. Теперь это JSON, который можно рассматривать тремя способами:

* Общий иерархический формат данных. Любой, кто думает, что это хорошая идея, должен прочитать раздел о модели данных в статье про IMS.
* Представление для разреженных данных. Рассмотрим атрибуты о сотруднике, и предположим, что мы хотим записать данные о хобби. Для каждого хобби данные будут разными, и хобби в основном разреженные. Это легко моделировать в реляционной СУБД, но это приводит к очень широким и очень разреженным таблицам. Это катастрофично для дисковых строковых хранилищ, но хорошо работает в колонковых хранилищах. В первом случае JSON является разумным форматом кодирования для столбца "хобби", и несколько РСУБД недавно добавили поддержку типа данных JSON.
* Механизм для "схемы при чтении". По сути, схема очень широкая и разреженная, и фактически всем пользователям потребуется некоторая проекция этой схемы. При чтении из широкой разреженной схемы пользователь может указать, что он хочет видеть во время выполнения. Концептуально это не что иное, как операция проекции. Таким образом, "схема при чтении" - это просто реляционная операция на данных, закодированных в JSON.

В итоге, JSON является разумным выбором для разреженных данных. В этом контексте я ожидаю, что он будет иметь определенный успех. С другой стороны, он является катастрофой в качестве общего иерархического формата данных. Я полностью ожидаю, что РСУБД воспримут JSON как просто один из многих типов данных в своих системах. Иными словами, это разумный способ кодирования разреженных реляционных данных.

Без сомнения, следующая версия Красной книги будет критиковать новый иерархический формат, изобретенный людьми, которые стоят на ногах своих предшественников, а не на их плечах.

Другой моделью данных, которая вызвала много шума за последнее десятилетие, является Map-Reduce, созданная Google для поддержки их базы данных веб-сканирования. Несколько лет спустя Google перестала использовать Map-Reduce для этого приложения, перейдя к Big Table. Теперь остальной мир видит то, что Google поняла раньше; Map-Reduce не является архитектурой с широкой применимостью. Вместо этого рынок Map-Reduce трансформировался в рынок HDFS и, похоже, готов стать рынком реляционного SQL. Например, Cloudera недавно представила Impala, которая является SQL-движком, построенным поверх HDFS, не используя Map-Reduce.

В последнее время появился еще один тренд в мире HDFS, который заслуживает обсуждения, а именно "озера данных". Разумное использование кластера HDFS (в который к этому времени большинство предприятий уже вложили средства и хотят найти для него полезное применение) заключается в очереди файлов данных, которые были загружены. Со временем предприятие поймет, какие из них стоит очистить (курирование данных, рассмотрено в главе 12 этой книги). Таким образом, озеро данных - это просто "мусорный ящик" для файлов на данный момент. Также у нас будет больше сказать об HDFS, Spark и Hadoop в главе 5.

В итоге, за последнее десятилетие никто, кажется, не учел уроков из "comes around". Были изобретены новые модели данных, которые только превратились в SQL на таблицах. Иерархические структуры были заново изобретены с предсказуемым результатом провала. Я не удивлюсь, если следующее десятилетие будет таким же. Люди, кажется, обречены изобретать колесо заново!

Что касается статьи об анатомии; всего через десятилетие мы можем отметить значительные изменения в том, как конструируются СУБД. Таким образом, детали изменились сильно, но общая архитектура, описанная в статье, все еще в основном верна. Статья описывает, как работают большинство устаревших СУБД (например, Oracle, DB2), и десятилетие назад это была распространенная реализация. Теперь эти системы являются историческими артефактами; не очень хорошими ни в чем. Например, в рынке хранилищ данных колонковые хранилища заменили строковые хранилища, описанные в статье, потому что они быстрее на 1–2 порядка величины. В мире OLTP основные SQL-движки с очень легким управлением транзакциями быстро становятся нормой. Эти новые разработки описаны в главе 4 этой книги. Теперь трудно найти область применения, где устаревшие строковые хранилища конкурентоспособны. Как таковые, они заслуживают отправки в "дом для вышедшего на пенсию ПО".

Трудно представить, что "один размер подходит всем" когда-либо снова станет доминирующей архитектурой. Таким образом, у "слонов" есть серьезная проблема "дилеммы инноваторов". В классической книге Клейтона Кристенсена он утверждает, что трудно для поставщиков устаревших технологий перейти на новые конструкции, не потеряв свою клиентскую базу. Однако уже очевидно, как "слоны" собираются пытаться это сделать. Например, SQLServer 14 представляет собой, по крайней мере, два движка (Hekaton - система OLTP в основной памяти и обычный SQLServer - устаревшее строковое хранилище), объединенные под общим парсером. Таким образом, стратегия Microsoft явно заключается в добавлении новых движков под их устаревший парсер и поддержке перемещения данных из устаревшего движка в более современные, не нарушая работы приложений. Остается увидеть, насколько это будет успешно.

Однако базовая архитектура этих новых систем продолжает следовать структуре парсера/оптимизатора/исполнителя, описанной в статье. Также модель потоков и структура процессов остаются столь же актуальными сегодня, как и десять лет назад. Таким образом, читатель должен отметить, что детали управления параллелизмом, восстановления после сбоев, оптимизации, структур данных и индексации находятся в состоянии быстрого изменения, но базовая архитектура СУБД остается неизменной.

Кроме того, уйдет много времени, прежде чем эти устаревшие системы исчезнут. Фактически, все еще существует огромное количество данных IMS в производственном использовании. Таким образом, любому студенту в этой области рекомендуется понять архитектуру (долгое время доминирующих) систем.

Более того, возможно, что аспекты этой статьи могут стать более актуальными в будущем по мере эволюции вычислительных архитектур. Например, грядущее появление энергонезависимой памяти может предоставить возможность для новых архитектурных концепций или возрождения старых.